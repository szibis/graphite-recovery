#!/usr/bin/python -tt
# -*- coding: utf-8 -*-

from pygtail import Pygtail
import threading
import Queue
import logging
import json
import re
import os
import resource
from boto import ec2
import boto.utils
from distutils.util import strtobool
import statsd
from recovery.configparse import ParseArgs
from recovery.ssh import SshRecovery
from recovery.http import HttpRecovery

logging.getLogger('paramiko.transport').addHandler(logging.StreamHandler())

config = ParseArgs.getconfig()

# Get config option
recovery = config.get('main', 'recovery')
graphite_dir = config.get('main', 'graphite_dir')
hosts = json.loads(config.get('main', 'hosts'))
carbon_creates = json.loads(config.get('main', 'carbon_creates'))
num_workers = int(config.get('main', 'num_workers'))
fd = int(config.get('main', 'fd'))
useec2 = config.getboolean('ec2', 'useec2')
aws_key_id = config.get('ec2', 'aws_access_key_id')
aws_key = config.get('ec2', 'aws_secret_access_key')
statsd_host = config.get('statsd', 'host')
statsd_port = config.get('statsd', 'port')
statsd_prefix = config.get('statsd', 'prefix')

# initialize statsd
sc = statsd.StatsdClient(str(statsd_host),
                         int(statsd_port),
                         prefix=statsd_prefix,
                         sample_rate=None)


class Recovery(threading.Thread):
    def __init__(self,
                 queue,
                 carbon_creates,
                 qcountall,
                 recovery):
        threading.Thread.__init__(self)
        self.queue = queue
        self.carbon_creates = carbon_creates
        self.qcountall = qcountall
        self.recovery = recovery

    def run(self):
        while True:
            try:
                wsp_file = self.queue.get(timeout=1)
                if self.recovery is "ssh":
                        SshRecovery.ssh_get(wsp_file)
                if self.recovery is "http":
                        HttpRecovery.http_get(wsp_file)
                sc.incr('QueueTasksGet')
            except Queue.Empty:
                break
            finally:
                try:
                    self.queue.task_done()
                    sc.incr('QueueTasksDone')
                except Exception:
                    break


def producer(carbon_creates, work):
    for line in Pygtail(carbon_creates):
        match = re.search(r"creating database file\s(.*)\s\(archive=",
                          line)
        if match:
            print "Add to queue: %s" % (match.group(1))
            work.put(match.group(1))


def main(carbon_creates,
         recovery):
    # Run the program
    queue = Queue.Queue()

    print "Adding elements to queue..."
    qcount = 0
    qcountall = 0
    for create_file in carbon_creates:
        for line in Pygtail(create_file, paranoid=True):
            match = re.search(r"creating database file\s(.*)\s\(archive=",
                              line)
            if match:
                qcount = qcount + 1
                queue.put(match.group(1))
                sc.incr('QueueTasksPut')
        print "Added %s path's from %s to queue...." % (qcount, create_file)
    qcountall = qcountall + qcount
    sc.gauge('QueueTasksPut', qcountall)

    print "Running threads....."
    tcount = 0
    try:
        for i in range(num_workers):
            t = Recovery(queue,
                         carbon_creates,
                         qcountall,
                         recovery)
            t.setDaemon(True)
            t.start()
            tcount = tcount + 1
        pid = os.getpid()
        print "Started %s threads on PID: %s" % (tcount, pid)
    except (KeyboardInterrupt, SystemExit):
        queue.join()
        queue.terminate()
    finally:
        queue.join()


if __name__ == '__main__':
    # set fd limit
    resource.setrlimit(resource.RLIMIT_NOFILE, (fd, fd))
    # check and use recovery tag in ec2 instance
    if useec2:
        instance_id = boto.utils.get_instance_metadata()['instance-id']
        region = boto.utils.get_instance_metadata()['placement']['availability-zone'][:-1]
        connection = ec2.connect_to_region(region,
                                           aws_access_key_id=aws_key_id,
                                           aws_secret_access_key=aws_key,
                                           is_secure=True)
        reservations = connection.get_all_instances()
        instances = [i for r in reservations for i in r.instances]
        for instance in instances:
            if instance.__dict__['id'] == instance_id:
                try:
                    tag_recovery = instance.__dict__['tags']['recovery']
                    bool_tag_recovery = bool(strtobool(tag_recovery))
                    if bool_tag_recovery is True:
                        recovery = True
                    else:
                        recovery = False
                except Exception:
                    recovery = False
                    pass
    if recovery is True:
        main(carbon_creates,
             recovery)
    else:
        print "If you use EC2 tag to start recovery you need add \
recovery tag with True on recovered instance"
