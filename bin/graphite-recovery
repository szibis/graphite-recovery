#!/usr/bin/env python -tt
# -*- coding: utf-8 -*-

import time
from pygtail import Pygtail
import ConfigParser
import threading
import Queue
import logging
import json
import re
import os
import resource
from boto import ec2
import boto.utils
from distutils.util import strtobool
import statsd
from recovery.configparse import ParseArgs
from recovery.ssh import SshRecovery
from recovery.http import HttpRecovery

logging.getLogger('paramiko.transport').addHandler(logging.StreamHandler())

parseargs = ParseArgs()
option = parseargs.parse_args()

if option.config is None:
    logging.error('No -c or --config option specified, for more use -h',
                  exc_info=True)
    exit(1)
else:
    config_opt = option.config
# Load config file
result = None
try:
    config = ConfigParser.RawConfigParser()
    result = config.read(config_opt)
except (SystemExit, KeyboardInterrupt):
    raise
except Exception:
    logging.error('Failed to open config file %s' % (config),
                  exc_info=True)
    exit(1)

# Get config option
recovery = config.get('main', 'recovery')
graphite_dir = config.get('main', 'graphite_dir')
hosts = json.loads(config.get('main', 'hosts'))
carbon_creates = json.loads(config.get('main', 'carbon_creates'))
num_workers = int(config.get('main', 'num_workers'))
fd = int(config.get('main', 'fd'))
match = config.get('main', 'regexp_match')
useec2 = config.getboolean('ec2', 'useec2')
aws_key_id = config.get('ec2', 'aws_access_key_id')
aws_key = config.get('ec2', 'aws_secret_access_key')
statsd_host = config.get('statsd', 'host')
statsd_port = config.get('statsd', 'port')
statsd_prefix = config.get('statsd', 'prefix')

# initialize statsd
sc = statsd.StatsdClient(str(statsd_host),
                         int(statsd_port),
                         prefix=statsd_prefix,
                         sample_rate=None)


class Recovery(threading.Thread):
    def __init__(self,
                 statsd,
                 queue,
                 carbon_creates,
                 qcountall,
                 recovery):
        threading.Thread.__init__(self)
        self.queue = queue
        self.carbon_creates = carbon_creates
        self.qcountall = qcountall
        self.recovery = recovery
        self.statsd = statsd

    def run(self):
        while True:
            try:
                wsp_file = self.queue.get(timeout=1)
                if self.recovery=='ssh':
                        sshrec = SshRecovery(self.statsd,
                                            wsp_file,
                                            self.qcountall)
                        sshrec.ssh_get()
                if self.recovery=='http':
                        httprec = HttpRecovery(self.statsd,
                                               wsp_file,
                                               self.qcountall)
                        httprec.http_get()
                sc.incr('QueueTasksGet')
            except Queue.Empty:
                break
            finally:
                try:
                    self.queue.task_done()
                    sc.incr('QueueTasksDone')
                except Exception:
                    break

def producer(carbon_creates, work):
    for line in Pygtail(carbon_creates):
        match = re.search(r"creating database file\s(.*)\s\(archive=",
                          line)
        if match:
            print "Add to queue: %s" % (match.group(1))
            work.put(match.group(1))


def main(carbon_creates,
         recovery):
    # Run the program
    queue = Queue.Queue()

    print "Adding elements to queue..."
    qcount = 0
    qcountall = 0
    for create_file in carbon_creates:
        for line in Pygtail(create_file, paranoid=True):
            match = re.search(r"{0}".format(match),
                              line)
            if match:
                qcount = qcount + 1
                queue.put(match.group(1))
                sc.incr('QueueTasksPut')
        print "Added %s path's from %s to queue...." % (qcount, create_file)
    qcountall = qcountall + qcount
    sc.gauge('QueueTasksPut', qcountall)

    print "Running threads....."
    tcount = 0
    try:
        for i in range(num_workers):
            t = Recovery(sc,
                         queue,
                         carbon_creates,
                         qcountall,
                         recovery)
            t.setDaemon(True)
            t.start()
            tcount = tcount + 1
        pid = os.getpid()
        print "Started %s threads on PID: %s" % (tcount, pid)
    except (KeyboardInterrupt, SystemExit):
        queue.join()
        queue.terminate()
    finally:
        queue.join()


if __name__ == '__main__':
    # set fd limit
    resource.setrlimit(resource.RLIMIT_NOFILE, (fd, fd))
    # check and use recovery tag in ec2 instance
    ec2tag_recovery = False
    if useec2:
        instance_id = boto.utils.get_instance_metadata()['instance-id']
        region = boto.utils.get_instance_metadata()['placement']['availability-zone'][:-1]
        connection = ec2.connect_to_region(region,
                                           aws_access_key_id=aws_key_id,
                                           aws_secret_access_key=aws_key,
                                           is_secure=True)
        reservations = connection.get_all_instances()
        instances = [i for r in reservations for i in r.instances]
        for instance in instances:
            if instance.__dict__['id'] == instance_id:
                try:
                    tag_recovery = instance.__dict__['tags']['recovery']
                    bool_tag_recovery = bool(strtobool(tag_recovery))
                    if bool_tag_recovery is True:
                        ec2tag_recovery = True
                    else:
                        ec2tag_recovery = False
                except Exception:
                    ec2tag_recovery = False
                    pass
    if ec2tag_recovery is True:
        main(carbon_creates,
             recovery)
    else:
        print "If you use EC2 tag to start recovery you need add \
recovery tag with True on recovered instance"
        time.sleep(2)
        main(carbon_creates,
             recovery)
